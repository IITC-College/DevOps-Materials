Below is the complete extraction of the latest questions (all in English), cleanly structured and ready for exam use.

---

## Question 1

**What is the fundamental difference between a Docker image and a Docker container?**

**Options:**

1. ✅ An image is a read-only, static blueprint containing the application and its environment, while a container is a live, running, and writable instance created from that image.
2. An image is stored in a remote registry, while a container only exists on a local machine.
3. An image includes the operating system kernel, while a container shares the kernel of the host.
4. Images are created with `docker run`, and containers are created with `docker build`.
5. There is no significant difference; the terms are used interchangeably.

**Correct Answer:** Option 1

---

## Question 2

A developer has a running container named `blue-server` which was started from the image `my-app:blue`. The developer then makes a code change, rebuilds the image, and applies the same tag `my-app:blue` to the new version.

**What happens to the running `blue-server` container?**

**Options:**

1. The code inside the running blue-server container is hot-swapped and updated without restarting.
2. The blue-server container automatically stops and restarts itself using the new image.
3. ✅ The blue-server container continues to run the original version of the code, completely unaffected by the new image build. Containers are linked to a specific image ID, not a mutable tag.
4. The blue-server container will crash because the image it was based on has been changed.
5. The container's image tag automatically updates to `my-app:blue_old` to avoid conflicts.

**Correct Answer:** Option 3

---

## Question 3

Each instruction in a Dockerfile (like `FROM`, `RUN`, `COPY`) creates a new layer in the final image.

**How does Docker leverage this layered architecture to speed up subsequent image builds?**

**Options:**

1. The layered architecture is only for organizing the image and has no impact on build speed.
2. It runs all instructions in parallel, using a separate CPU core for each layer.
3. It combines all layers into a single flattened layer before the build begins, which is faster to process.
4. Docker pre-downloads all potential layers from Docker Hub before the build starts.
5. ✅ Docker caches the result (the intermediate image layer) of each instruction. If an instruction and its inputs have not changed since a previous build, Docker reuses the cached layer instead of re-executing the instruction.

**Correct Answer:** Option 5

---

## Question 4

Why is using a Dockerfile considered the standard and best practice for creating Docker images, as opposed to creating an image from a running container using `docker commit`?

**Options:**

1. ✅ A Dockerfile provides a clear, version-controlled, and reproducible "recipe" for building the image. It documents the entire process and allows for easy automation in CI/CD pipelines.
2. `docker commit` creates images that are much larger than those created from a Dockerfile.
3. Images created with `docker commit` cannot be pushed to a container registry.
4. `docker commit` is a deprecated command and will be removed in future versions of Docker.
5. Using a Dockerfile is faster than using `docker commit`.

**Correct Answer:** Option 1

---

## Question 5

A developer's `docker build` command is failing on the `COPY` instruction. The file `config/prod.json` definitely exists on their machine.

### Directory Structure:

```
/home/user/project/
├── app/
│   ├── Dockerfile
│   └── main.py
└── config/
    └── prod.json
```

### Dockerfile content (inside `app/`):

```
FROM python:3.9-slim
WORKDIR /app
COPY main.py .
COPY config/prod.json /app/config/
CMD ["python", "main.py"]
```

### Command executed from:

```
/home/user/project/app/
docker build -t my-app .
```

**What is the most likely cause of the error?**

**Options:**

1. The `COPY` command cannot copy entire directories; you must copy files one by one.
2. ✅ The build context is set to `.` (the `app/` directory), but the `config/prod.json` file is located outside of that directory. The Docker daemon only has access to files within the build context.
3. The destination path `/app/config/` does not exist inside the container, and `COPY` cannot create new directories.
4. The file path in the `COPY` instruction should be an absolute path on the host machine.
5. The file `prod.json` is in a text format, and `COPY` only works for binary files.

**Correct Answer:** Option 2
