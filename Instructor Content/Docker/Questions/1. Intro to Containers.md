## Question 1

**שאלה:**
A development team is struggling with the "it works on my machine" problem, where an application runs perfectly on a developer's laptop but fails in the testing environment due to differences in library versions and system configuration. How does containerization primarily solve this issue?

**אפשרויות:**

1. By providing a hypervisor that translates system calls between different operating systems.
2. ✅ By bundling the application with all its specific dependencies, libraries, and configurations into a single, immutable container image, which ensures that the environment is identical wherever the container is run.
3. By automatically updating all dependencies to their latest versions during deployment.
4. By creating a full virtual machine for each developer to ensure their environments are isolated.
5. By requiring all developers and servers to use the exact same hardware.

**תשובה נכונה:** אפשרות 2

---

## Question 2

**שאלה:**
You need to deploy a new microservice-based, cloud-native application. The key requirements are rapid scalability, high resource efficiency (running as many instances as possible on the hardware), and fast startup times. In this scenario, what is the most appropriate technology to use and why?

**אפשרויות:**

1. Virtual Machines (VMs), because they are more portable than containers.
2. Virtual Machines (VMs), because they offer the strongest possible security isolation between services.
3. ✅ Containers, because they are lightweight, share the host OS kernel, have minimal overhead, and can be started in seconds, making them ideal for scaling microservices efficiently.
4. Containers, because they each include their own complete guest operating system.
5. A hybrid approach, running each microservice on a separate physical server for maximum performance.

**תשובה נכונה:** אפשרות 3

---

## Question 3

**שאלה:**
A developer runs the command `docker run nginx` on their machine for the very first time. The nginx image is not present locally. Which of the following sequences of events correctly describes what happens behind the scenes?

**אפשרויות:**

1. ✅ The Docker Client sends the command to the Docker Daemon (on the Docker Host). The Daemon checks its local image cache, doesn't find the nginx image, pulls the image from a public image registry (like Docker Hub), stores it in the local cache, and then starts a new container based on that image.
2. The Docker Client directly downloads the nginx image from the internet and then tells the Docker Daemon to run it.
3. The Docker Daemon creates an empty container and then installs Nginx inside it from scratch.
4. The command fails because the nginx image must be built locally using `docker build` before it can be run.
5. The Docker Client sends the command to the image registry, which then pushes a new container directly to the Docker Host.

**תשובה נכונה:** אפשרות 1

---

## Question 4

**שאלה:**
A developer makes the following statement:
"Containers are great because they are completely independent of the host machine. I can take a container running on a Linux server and run it directly on a Windows server without any issues because the container includes its own Linux guest OS."
What is the fundamental misconception in this statement?

**אפשרויות:**

1. The statement is correct; this is exactly how containers work.
2. Containers are less portable than Virtual Machines.
3. Windows servers cannot run Docker at all.
4. The developer should have used the `docker push` command to move the container from Linux to Windows.
5. ✅ Containers do not have a guest OS. They share the kernel of the host operating system. A standard Linux container cannot run natively on a Windows kernel; it requires a compatibility layer (like WSL2) to provide a Linux kernel.

**תשובה נכונה:** אפשרות 5

---

## Question 5

**שאלה:**
A developer has just written a Dockerfile for their new application. They run `docker build -t my-app:1.0 .` and it completes successfully. A colleague on a different machine then tries to run `docker run my-app:1.0` but gets an "image not found" error. What crucial step was missed in the workflow?

**אפשרויות:**

1. The colleague's Docker Daemon is not running.
2. The docker build command was run with the wrong tag; it should have been `-t my-app/1.0`.
3. The colleague needs to run `docker pull my-app:1.0` before running it.
4. ✅ The developer who built the image never pushed it to a shared image registry. The `docker build` command only creates the image in the local cache of their own Docker Host.
5. The Dockerfile must be copied to the colleague's machine so they can build the image themselves.

**תשובה נכונה:** אפשרות 4

---

## Question 6

**שאלה:**
Which of the three main Docker components is primarily responsible for managing the lifecycle of containers (starting, stopping, etc.) and managing images (pulling, storing, removing)?

**אפשרויות:**

1. The Image Registry (e.g., Docker Hub).
2. The Docker Client (the docker CLI).
3. ✅ The Docker Daemon (or Docker Engine), which runs on the Docker Host.
4. The Dockerfile.
5. The Hypervisor.

**תשובה נכונה:** אפשרות 3

---

אם תרצה עכשיו:

* מפתח תשובות מרוכז להדפסה
* גרסה נקייה לסטודנטים ללא סימון תשובות
* חלוקת ניקוד
* המרה ל-Google Form
* בניית גרסת קושי גבוהה יותר
* או יצירת שאלות חדשות באותו סגנון

תגיד לי לאיזה פורמט אתה רוצה להמשיך.
